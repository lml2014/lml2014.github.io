<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo主题安装]]></title>
    <url>%2F2019%2F07%2F20%2Fhexo%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[简介目前博客有很多方式可以书写，如简书，CSDN等等，由于经常使用Git，故打算采取hexo进行自主博客的搭建。github是支持个人主页的博客搭建和项目的博客搭建的，很是方便了，一下便是采取hexo进行的个人博客的搭建过程。 安装Hexo首页，我们进行hexo的安装。电脑上需要安装好基本的工具npm，node等等。安装hexo脚手架，命令： 1npm install -g hexo-cli 安装好脚手架之后，新建一个空的目录folder，用来放置个人hexo生成博客源码的文件。进入文件夹，初始化hexo： 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 经过以上几个步骤，hexo就搭建完成了，可以进行hexo的操作了。 具体的可以参考官方：hexo官方文档 Hexo命令介绍经过npm之后，hexo结构项目是有了。此时，运行hexo server就会进行项目的启动了，启动成功之后，访问localhost:4000即可看到默认的基础博客了。后续我们写的文章都会在此生成的展现出来的。 hexo常见命令如下： 123456hexo clean --清除缓存hexo generate --生成个人博客所需的静态页面hexo server --本地预览hexo deploy --部署我们的个人博客hexo new &quot;postName&quot; --新建文章hexo new page &quot;pageName&quot; --新建页面 hexo server 命令运行后，可以直接启动博客系统，方便我们立刻查看，写的文章效果呈现。 hexo generate 是生成博客文档的。运行此命令之后，我们的所有博客都会经过组织生成html文件，并放置到public文件夹下，运行此命令之后，就可以看到public文件夹，里面就是博客网站的源码。 hexo clean 会将生成的public文件进行清空删除操作。 hexo deploy 是可以将我们系统生成的public文件夹所有内容，上传到指定地方去。例如：git。配置之后，当执行此命令，就会将public所有文件上传到git所在仓库中去。 hexo new 最常用的命令，写篇文章时，就需要运用此命令了。会在hexo的源文件source下生产markdown文件，然后就可以进行书写了。 hexo new page 生成页面，hexo生成的博客，默认上面只有首页，归档等等。类别不多，当我们需要其他的例如：分类，标签的时候，就需要运行此命令处理了。 Next主题hexo生成的博客样式是默认样式，放在theme目录下，我们可以选择其他博客样式来展示的。很简单，仅仅需要将需要展示的主题放入/theme/目录下，然后修改配置文件_config.xml文件中的theme即可。目前最流行的hexo主题是next，下面就展示如何安装。 12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 经过以上命令，就将next主题下载到了themes/next目录下了，然后修改配置文件_config.xml将theme修改下theme: next就已经应用好了主题了。 具体的参考官网：next官方文档 Github上传我们的博客生成好了之后，是放到public目录下面的，只能自己查看其他人也无法查看。此时，可以将public下的源码放到服务器上就可以了。服务器还需要单独购买，此时，我们可以选择放到Github上，Github的github pages是支持直接展示html的。 搜索github pages了解此项功能后，然后在Github上新建以username.github.io的仓库，这个仓库只能建立一个。建立好了之后，我们就可以把hexo生成的public文件放到项目中了。放置好了之后，直接访问username.github.io就可以看到博客了。 hexo可以结合github进行自动上传操作，进入_config.xml配置文件，设置deploy命令即可。 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 注：type类型最新的hexo是git了，不是github。 Github源码保存使用上面方式是可以部署github，但是此时git上面的master只有生成的博客文件，并没有我们的各种配置和源码。故，我们需要将源码也保存到github上面去，当本地环境变了之后，仍然能够进行构建。 复用之前的git仓库，建立hexo分支。（master分支只能放置博客文件，源码只能放置其他分支上面去）此时，hexo分支保存我们hexo init操作后的源码，即_config.xml根目录。源文件修改后，立刻进行hexo分支的推送保存操作。然后执行hexo generate &amp;&amp; hexo deploy命令，进行public文件的生成，并自动上传到github的mater分支上面去。 可以参考博客进行处理：静态博客Hexo搭建 —— 本地、服务器两开花 Hexo主题的源码上传上面可以将hexo源码上传到github上去，但是我们的主题处理上面就有些费事了，我们的主题会有很多个性化的设计的。以下有2种方式可以选择处理。 Hexo的主题当做文件来处理 下载主题并复制到themes/目录下面去，删除主题的.git配置文件，将主题的git项目全部当做普通该文件处理，此时主题也是hexo源码的一部分了。优点：方便，便捷。缺点：主题不好升级。 Hexo的主题也是git项目 下载主题到themes/目录下，此时的主题也是一个git项目，相当于hexo源码是个git项目，里面的主题又是一个git项目，此时，采取git的子模块形式，运行git submodule add xxx将主题的git仓库当做hexo源码的子模块即可。 主题由于是子模块，就可以进行升级操作了。而主题则从选择的官方主题git仓库那里fork一份到自己仓库中，如此，主题的配置也会保存下来了。 这里参考博客： hexo 使用子模块实现自定义主题与hexo文件分离，在两个git维护 与Travis CI构建自动上传上面虽然解决了源码保存和生成问题，但是每次写文章还需要进行博客的生成和提交操作，还是比较费事的，此时，可以采取Travis CI进行自动编译保存上传操作。 到travis.com下进行账号注册，关联到github上面去。然后编写脚本进行自动上传和保存操作。注意：travis.org仅可构建公开项目，已经逐渐废弃了，后续全部迁移到travis.com上去，即可构建公开项目，又可构建私有项目。这里容易让人纠结，可参考：What’s the difference between travis-ci.org and travis-ci.com? 至于travis的编写，还有自动上传之后，提交记录等等很多问题。目前网上有很多方案，个人看了很多，都觉得不满意，而且很混杂，处理方式什么都有。不是很好的方案，最终搜到这篇文章： 使用Travis CI自动部署Hexo博客 这篇文章详细介绍了与travis结合遇到的各种问题，很是全面。本人最后也是采取此方式处理的，很好，很强大。如果要配置的话，建议进入此博主的github项目，找到他构建的github pages，拷贝出来自动上传配置文件即可。 注：强烈建议查看此博客进行travis自动上传，本人博客也是拷贝此博客配置文件来的，目前运行极好。 后记当初就知道hexo，一直没有手动完全了解过。这次由于一些原因，下决心整理下hexo的完全搭建步骤，中途看了很多文章，才算是摸清了解一些内容，此篇文件也是将大体流程梳理下了，其中涉及到的部分小细节也没详细说明了，靠个人理解下了。了解到了写个博客，打字整理也是很费时间的了。 参考以下博客可以进行参考，进行theme的优化等。 Hexo-NexT配置超炫网页效果 我的个人博客之旅：从jekyll到hexo GitHub+Hexo 搭建个人网站详细教程 2018最新版hexo+Github搭建个人博客教程（2018-09-10 更新） Hexo+NexT 打造一个炫酷博客 使用Travis CI自动构建hexo博客 如何优雅地发布Hexo博客–使用ngxin,hexo-admin 使用Hexo搭建博客之进阶篇 静态博客Hexo搭建 —— 本地、服务器两开花 使用 Travis CI 自动部署 Hexo 博客 使用hexo搭建的网站，并含有hexo优化]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-GC Overhead Limit Exceeded]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-GC%20Overhead%20Limit%20Exceeded%2F</url>
    <content type="text"><![CDATA[标题OutOfMemoryError: GC Overhead Limit Exceeded 前言本文翻译自 http://www.baeldung.com/java-gc-overhead-limit-exceeded 正文 概述当对象不再被使用时，JVM会小心地释放它所占用的内存，这个进行被叫做Garbage Collection（GC）。异常GC Overhead Limit Exceeded error是java.lang.OutOfMemoryError家族的一员，并且很明显地它表示了资源（内存）消耗殆尽。在下面的文章中，我们将会寻找是什么原因导致了java.lang.OutOfMemoryError: GC Overhead Limit Exceeded error并且如何解决它们。 GC Overhead Limit Exceeded ErrorOutOfMemoryError是java.lang.VirtualMachineError的子类，当JVM遇到与资源利用有关的问题时，就会抛出这个异常。更确切的说，当JVM花费了太多时间执行垃圾收集时，这个错误就会发生并且它回收的堆内存很少。按照Java文档的说法，默认情况下，JVM配置如果java进程花费超过98%的时间来做GC但是每次只能回收2%不到的堆内存，那么这个错误就会被抛出。换句话说，这意味着我们的应用程序用尽了几乎所有可用的内存，垃圾收集器花费了太多的时间来清理它，并且多次失败了。在这种情况下，用户就会感觉到应用程序特别慢。某些通常亿毫秒为单位完成的操作，此时也需要更长的时间才能完成了。这是因为CPU正在使用它全部的能力在垃圾收集器上，因此不能够执行其他的任务了。 错误的场景让我们来看一段运行代码能够抛出’java.lang.OutOfMemoryError: GC Overhead Limit Exceeded.’例如，我们可以完成这段代码，添加key-value的对到一个无结束的循环中。123456789public class OutOfMemoryGCLimitExceed &#123; public static void addRandomDataToMap() &#123; Map&lt;Integer, String&gt; dataMap = new HashMap&lt;&gt;(); Random r = new Random(); while (true) &#123; dataMap.put(r.nextInt(), String.valueOf(r.nextInt())); &#125; &#125;&#125; 当方法被执行时，带有JVM参数：-Xmx100m -XX:+UseParallelGC（堆内存设置为100MB并且GC算法采取ParallelGC）我们能够得到错误java.lang.OutOfMemoryError: GC Overhead Limit Exceeded error，为了能够更好的理解不同的垃圾收集器算法，我们可以查看Oracle的文档Java Garbage Collection Basics我们也可以快速运行以下的命令在项目根路径得到异常java.lang.OutOfMemoryError: GC Overhead Limit Exceeded error 1mvn exec:exec 还需要注意点的是，在某些场景下，我们可能在GC Overhead Limit Exceeded错误之前遇到heap space error 解决GC Overhead Limit Exceeded Error去解决这个应用程序根本的问题是去检查引起任何内存泄漏的代码。以下的问题需要去处理： 程序中哪个对象占据这大量的堆内存空间？ 那一部分代码是分配这些对象的？我们也可以使用自动化的图形工具例如JConsole来检测袋中包含java.lang.OutOfMemoryErrors的性能问题。最后的办法是通过改变JVM的启动配置来增加堆的大小。例如为这个应用程序分配1G的堆内存空间。1java -Xmx1024m com.xyz.TheClassName 然后，如果应用程序代码中真正存在内存泄漏，这种方法将不会解决问题。相反，我们将会延期这个错误。因此，更可取的是要彻底重新评估应用程序的内存使用。 结论在这个指导中，我们已经明确了java.lang.OutOfMemoryError: GC Overhead Limit Exceeded异常，并且知道了它背后的原因。一如既往，可以找到与本文相关的源代码(Over on GitHub)[https://github.com/eugenp/tutorials/tree/master/core-java]]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-Requested array siz]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-Requested%20array%20siz%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError:Requested array size exceeds VM limit 前言本文翻译自 https://plumbr.io/outofmemoryerror/requested-array-size-exceeds-vm-limit OverView在你的应用程序分配内存时，java有个最大的数组长度限制。确切的来说，它限制的是特定的平台，一般是1到2.1亿个元素。 当你面对java.lang.OutOfMemoryError: Requested array size exceeds VM limit异常时，它意味着应用程序奔溃了，这个错误是应用程序尝试去申请一个大数组超过了java虚拟机能够支持的限度。 What is causing it?这个错误是由JVM本地代码抛出的错误。它发生在你申请一个数组内存之前，当JVM执行特定平台的检查时：在这个平台中，无论分配好的数据结构是否是可用的。在你最初的思考中，这个错误是不常见的。 你几乎很少面对这个错误的原因是Java数组是由int索引的。这个最大的位置int是2^31-1=2,147,483,647。并且在特定平台中，这个限制能够被关闭–例如，在我64位的MB Pro的java 1.7版本中，我能够初始化这个数组尺寸到2,147,483,645或者Integer.MAX_VALUE-2个元素。 增加这个数组的长度1位到Integer.MAX_VALUE-1的结果就是OutOfMemoryError。 1Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Requested array size exceeds VM limit 但是这个限制可能不会超过这个高度–再32位的Linux带有OpenJDK6中，你将会得到java.lang.OutOfMemoryError: Requested array size exceeds VM limit错误当你分配一个数组带有1.1亿的元素时。为了理解特定环境的限制，运行下一章中描述的小测试程序。 Give me an example运行如下的代码将会得到错误： 12345678for (int i = 3; i &gt;= 0; i--) &#123; try &#123; int[] arr = new int[Integer.MAX_VALUE-i]; System.out.format(&quot;Successfully initialized an array with %,d elements.\n&quot;, Integer.MAX_VALUE-i); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125;&#125; 该示例迭代四次，并在每个回合中初始化长基元数组。这个程序试图初始化的数组的大小随着每次迭代增长一个，最后到达整数。现在，当用热点7启动64位Mac OS X上的代码片段时，应该得到与以下类似的输出： 12345678java.lang.OutOfMemoryError: Java heap space at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Java heap space at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Requested array size exceeds VM limit at eu.plumbr.demo.ArraySize.main(ArraySize.java:8)java.lang.OutOfMemoryError: Requested array size exceeds VM limit at eu.plumbr.demo.ArraySize.main(ArraySize.java:8) 最后2次发生了异常java.lang.OutOfMemoryError: Requested array size exceeds VM limit，还有常见的java.lang.OutOfMemoryError: Java heap space message.它发生是因为你尝试在8G的内存冲分配2^31-1个int原始空间，这些内存空间是少于默认的JVM内容的。 这个错误也论证了为什么这个错误这么少见–为了看到JVM限制array size，你需要分配array的大小在正确的范围介于平台和限制和Integer.MAX_INT之间。当我们的例子是运行在Mac OS X的64位Hotspot 7机器时，这里只有2个array的length限制：Integer.MAX_INT-1和Integer.MAX_INT What is the solution?这个错误会在以下情况下发生： 你的数组增长过快，并且拥有的大小在平台限制和Integer.MAX_INT之间 你故意去分配数组的长度让他超过2^31-1个元素。 在第一种情况中，检查你的代码去确认你真的需要数组长度这么大。或许你可以减少数组的长度。或者分割你的数组到更小的数据块中，当你需要这个数据时，分批次的加载这些数据信息。 在第二种情况中，要记得java的数组是int索引的。因此，当使用标准的数据结构时，你不能分配超过2^31-1个元素。事实上，你在编译阶段就会得到错误信息“error: integer number too large”来阻止你。 如果你真正需要这么大的数据，你应该重新思考下你的选项。你可以加载你需要的数据在更小的批次数据中，这样仍然可以使用java弓箭。或者你使用其他的标准工具。另一种方式是查看sun.misc.Unsafe的实现。这个允许你分配直接分配内存就像C语言一样。]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-Permgen space]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-Permgen%20space%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError:Permgen space 前言本文翻译自 https://plumbr.io/outofmemoryerror/permgen-space OverViewJava应用程序仅仅被允许使用有限的内存。当应用启动的时候，你的应用就确定了可以使用的内存量。为了让事情更复杂，Java内存分为下面的图中可以看到的不同的地区： 这些区域包括permgen区域，都在JVM启动时，被设置了。如果你没有设置这些，那么将会采取平台默认值。 当抛出错误java.lang.OutOfMemoryError: PermGen space时，这表明了永久带的内存被耗尽了 Permanent Generation’s area in memory is exhausted. What is causing it?为了理解什么样的错误会导致java.lang.OutOfMemoryError: PermGen space，我们需要知道什么样的对象会使用这片内存区域。 实际上，永久带主要将类的声明加载和存储放到了PermGen。这包括了类的名称和类的字段，带有字节码的方法、常量池信息、类关联的对象数组和类型数组以及编译器优化。 从以上定义可以推断，永久代大小要求取决于加载的类的数量以及此类声明的大小。因此我们可以说，导致java.lang.OutOfMemoryError: PermGen space错误主要是加载了太多的类或者加载了太大的类在永久带。 the main cause for the java.lang.OutOfMemoryError: PermGen space is that either too many classes or too big classes are loaded to the permanent generation Give me an exampleMinimalistic example如上文所述，PermGen空间的使用是和加载到JVM类的数量有密切关系的。以下代码是最常见的例子： 1234567891011121314import javassist.ClassPool;public class MicroGenerator &#123; public static void main(String[] args) throws Exception &#123; for (int i = 0; i &lt; 100_000_000; i++) &#123; generate(&quot;eu.plumbr.demo.Generated&quot; + i); &#125; &#125; public static Class generate(String name) throws Exception &#123; ClassPool pool = ClassPool.getDefault(); return pool.makeClass(name).toClass(); &#125;&#125; 这个例子中运行时循环创建类，这些类的生成由javassist library提供了。 启动上面的代码中会不断生成新的类，其定义加载到Permgen空间，直到充分利用了此空间。直到充分利用空间java.lang.OutOfMemoryError: Permgen space. Redeploy-time example对于更复杂和更实际的应用，让我们来查看下，通过java.lang.OutOfMemoryError: Permgen space错误产生在服务重新部署时。当你重新部署这个服务器的时候，你期望GC会去除持有以前加载所有类引用的类加载器，并且能够替换为一个加载这些新类版本的新类加载器。 不幸的是，许多第三方库和资源处理不善，如线程、JDBC驱动程序或文件系统处理使得卸载先前使用的类加载器不可能。这意味着在每个部署期间，所有类的早期版本仍将驻留在永久代在每个部署期间生成几十兆的垃圾 during each redeploy all the previous versions of your classes will still reside in PermGen generating tens of megabytes of garbage during each redeploy. 让我们想象一个示例应用程序，它使用JDBC驱动程序连接到一个关系数据库。当应用程序启动时，初始化代码将加载JDBC驱动程序连接到数据库。根据响应的规范，JDBC驱动将会自己注册* java.sql.DriverManager。这个注册包括了存储了一个包含DriverManager*静态字段的驱动实例。 现在，从应用服务器中部署应用程序时，java.sql.DriverManager将仍然持有这个引用。我们最终会有一个存活的驱动类实例。这个驱动类这反过来又包含对java.lang.Classloader的引用去加载这个应用程序。这意味着Garbage Collection算法不能回收这个区域。 java.lang.ClassLoader将仍然引用着应用程序所有的类，通常在永久代占领几十兆。 这意味着它将采取一点点重新部署，以填补一个通常大小的永久代空间，最后你将在你的日志中看到java.lang.OutOfMemoryError: PermGen space错误。 What is the solution? Solving initialization-time OutOfMemoryError当应用程序运行时，OutOfMemoryError由PermGen耗尽触发时，解决办法很简单。应用程序仅仅需要更多的空间去加载所有的类在PermGen中，我们仅仅需要去增加它的尺寸就好。改变你的应用程序启动配置和添加-XX：MaxPermSize参数与以下示例类似：1java -XX:MaxPermSize=512m com.yourcompany.YourClass 上述配置会告诉JVM，永久代将增长到512MB，在程序开始溢出内存错误之前。 Solving redeploy-time OutOfMemoryError可以采取使用Plumbr软件，如果不能使用Plumbr那些的，替代品也可以。为此，应继续按照堆转储分析一样，在一个部署后，生成堆转储命令与此类似：1jmap -dump:format=b,file=dump.hprof &lt;process-id&gt; 然后打开转储您最喜欢的堆转储分析(Eclipse MAT为那是一个很好的工具)。在分析器中，可以查找重复的类，特别是加载您的应用程序类。从那里，你需要对所有的类加载器的进展，以找到当前活动的类加载器。 为非活动的类加载器，您需要确定参考阻止他们被垃圾收集通过收集到的垃圾回收根节点的最短路径从非活动的类加载器。配备这些信息，您就找到了根源。在案件的根源是第三方库中，您可以继续谷歌/堆栈溢出，看看是否这是一个已知的问题得到一个修补程序或解决方法。如果这是您自己的代码，你需要摆脱违规参考。 Solving run-time OutOfMemoryError另一种方式再次为那些无法使用Plumbr也都是可用的。在这种情况下，第一步是检查是否从永久代GC允许卸载类。标准JVM在这方面是相当保守的–类天生就会永远活着。所以一旦装入，类留在记忆里，即使没有代码使用他们了。当应用程序创建动态很多类和生成的类不需要长时间时，这会成为一个问题。在这种情况下，允许JVM卸载类定义可以是有益的。这可以通过只是一个配置参数添加到您的启动脚本：1-XX:+CMSClassUnloadingEnabled 默认情况下此选项设置为false，以便这一点，你需要在Java选项显式设置以下选项。如果启用CMSClassUnloadingEnabled，GC也会打扫永久代和删除不再使用的类。请记住，此选项只能在UseConcMarkSweepGC也启用时，使用下面的选项。所以在运行时，ParallelGC或者，上帝保佑，串行GC，确保你有你的GC设置为CMS通过指定： 1-XX:+UseConcMarkSweepGC 在确保类之后，可以卸载和问题仍然存在，应继续按照堆转储分析–获取的堆转储一个类似于以下命令： 1jmap -dump:file=dump.hprof,format=b &lt;process-id&gt; 然后打开转储文件与您最喜爱的堆转储分析(例如。日食MAT)和进步，以找到最昂贵的类加载器加载的类的数量。从这样的类加载器，您可以继续提取装入的类和排序这样的类的实例有嫌疑人的列表顶部。 每一个猜想，您需要手动回您的应用程序生成这些类的代码跟踪的根源。]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-Out of swap space]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-Out%20of%20swap%20space%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError:Out of swap space? 前言本文翻译自 https://plumbr.io/outofmemoryerror/out-of-swap-space java应用程序在启动时，就被限制使用一定量的内存。这个限制是通过几个指定的参数-Xmx和其他类似的启动的参数。在另一种场景中，JVM所要求的总内存大于可用的物理内存，操作系统启动时将替换硬盘内容到内存。 错误java.lang.OutOfMemoryError: Out of swap space表明交换空间也耗尽，由于缺乏物理内存和交换空间的新尝试分配失败。 What is causing it?错误java.lang.OutOfmemoryError: Out of swap space将会被抛出，当JVM在堆中的字节分配失败时，并且本地的堆将会耗尽。这个信息表明了分配的大小（bytes大小）是失败的，并且是由于内存请求的原因。 这个问题发生在这种场景就是Java进程已经开始了交换，但是java垃圾收集的回收并不在一个不合适的场景。现在的GC算法并不是很好，但当面对延迟所引起的问题交换，GC中断倾向于增大这个级别，这个级别是大多数的应用程序所不能容忍的。 错误java.lang.OutOfMemoryError: Out of swap space经常有操作系统级别的错误导致，例如： 操作系统配置了一个不足的swap空间。 操作系统的其他程序消耗了所有的内存资源。 有时候也可能是应用程序的错误归因于本地泄漏，例如，应用程序不断的申请内存但是缺不释放这个操作系统的内存。 What is the solution?为了克服这个问题，你有一下几种方式。最简单和最常用的方式就是去增大swap空间。这意味是平台相关的。例如，在Linux上，你可以输入以下几个命令，创建并且达到一个新的640MB的swapfile。 1234swapoff -a dd if=/dev/zero of=swapfile bs=1024 count=655360mkswap swapfileswapon swapfile 你应该晓得，由于垃圾收集器清扫内存内容，这使得一般的Java进程的交换不可用。运行中的垃圾收起算法在交换分配区能够增加这个GC暂定好几个数量级，因此，你应该多思考下是否使用最简单的办法处理这种情况。 如果您的应用程序部署的旁边有”吵闹的邻居”，即需要JVM去争夺资源，你应该隔离这些服务分离(虚拟)的机器。 然而在大多数情况下，你唯一真正可行的选择是要么机器升级到包含更多的内存或优化应用程序以减少内存占用。当你转向优化这条路时，一个开始的好方法是使用内存转储分析器来检测分配的内存。]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-new native thread]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-new%20native%20thread%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError:Unable to create new native thread 前言本文翻译自 https://plumbr.io/outofmemoryerror/unable-to-create-new-native-thread Overviewjava应用程序天生就是多线程的。这个意思就是说用java编写的程序看起来同一时刻可以做好几个事情。例如–即时只有在一个处理器上–当你从一个窗口内容拖动到另一个时，后台的音乐播放并没有停止，因为你可以在此时执行好几个操作。 一个思考线程的方式是你把它当做工人给他们任务去执行。当你只有一个工人的时候，他只能去做一个任务。但当你有很多工人时，他们可以同时完成几个命令。 现在，正如现实世界的工人一样，JVM的线程需要一些空间去执行这些他们被分配处理的工作。当这里更多的线程超过了他们在内存的空间时，我们就产生了一个基础的问题： 错误信息java.lang.OutOfMemoryError: Unable to create new native thread意思是Java应用程序已达到它能启动多少线程的限制。 Java application has hit the limit of how many Threads it can launch What is causing it?当JVM要求一个OS提供一个新线程的时候，你有一个机会去展示这个错误java.lang.OutOfMemoryError: Unable to create new native thread.只要底层的OS无法分配一个新的线程，那么就将会引发OutOfMemoryError的抛出。本地线程的限制是十分依赖于平台的。因此我们建议可以通过运行以下的测试例子来测试。但是，一般来说，java.lang.OutOfMemoryError: Unable to create new native thread抛出的情况会经过以下这几个阶段： 在JVM中当应用程序申请一个新的java线程。 JVM本地代码代理了这个请求在OS操作系统上去创建一个新的线程。 OS操作系统尝试创建一个新的线程，这需要内存分配给线程。 因为32位Java进程耗尽了它的内存地址空间大小，操作系统会拒绝任何本机内存分配。–（2-4）GB进程大小被击中–操作系统的虚拟内存已完全耗尽。 java.lang.OutOfMemoryError: Unable to create new native thread error此时就会抛出。 Give me an example以下代码创建并且开启线程在循环中。当运行这个代码的时候，操作系统会限制的非常快，并且java.lang.OutOfMemoryError: Unable to create new native thread message将会展示： 123456789while(true)&#123; new Thread(new Runnable()&#123; public void run() &#123; try &#123; Thread.sleep(10000000); &#125; catch(InterruptedException e) &#123; &#125; &#125; &#125;).start();&#125; 这个精确的线程限制是依赖于平台的，例如在Windows,Linux和Mac OS X呈现： 64-bit Mac OS X 10.9,Java 1.7.0_45-JVM在创建了#2031线程之后挂了 64-bit Ubuntu Linux, Java 1.7.0_45-JVM在创建了#31893线程之后挂了 64-bit Windows 7, Java 1.7.0_45-由于由操作系统使用不同的线程模型,似乎没有引发此错误在这个特殊的平台。在线程是@250000进程之后仍然存活，即使交换文件已增加到10GB，该应用程序正面临极端性能问题。 所以确保你知道的机器极限可以通过调用一个小的测试，然后找出什么时候将会触发java.lang.OutOfMemoryError: Unable to create new native thread错误。 What is solution?偶尔你可以绕过这个限制通过增加OS的限制。例如，如果你已经限制了程序的数量。JVM可以在用户空间引发这个检查，并且这个限制还会增大： 1234[root@dev ~]# ulimit -acore file size (blocks, -c) 0--- cut for brevity ---max user processes (-u) 1800 通常来说不会的，程序错误时OoutOfMemoryError将会表明新的线程无法创建。当在您的应用程序中生成成千上万的线程时，那么有些东西已经发生了可怕的错误–这里将不会有很多应用程序受益于这样一个巨大的线程的数量。 解决这个问题的一个方法是开启一个任务线程去dumps这些东西，并去了解这个和场景。这通常需要花费部分时间。]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-All]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-All%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError The 8 symptoms that surface them(8个表面症状)The many thousands of java.lang.OutOfMemoryErrors that I’ve met during my career all bear one of the below eight symptoms. This handbook explains what causes a particular error to be thrown, offers code examples that can cause such errors, and gives you solution guidelines for a fix. The content is all based on my own experience.(平时遇到了很多的OOM错误，以下是常见的8种情况，我总结了常见错误原因和例子) Nikita Salnikov-TarnovskiPlumbr Co-Founder and VP of Engineering java.lang.OutOfMemoryError:Java heap space java.lang.OutOfMemoryError:GC overhead limit exceeded java.lang.OutOfMemoryError:Permgen space java.lang.OutOfMemoryError:Metaspace java.lang.OutOfMemoryError:Unable to create new native thread java.lang.OutOfMemoryError:Out of swap space? java.lang.OutOfMemoryError:Requested array size exceeds VM limit Out of memory:Kill process or sacrifice child]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-Metaspace]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-Metaspace%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError:Metaspace 前言本文翻译自 https://plumbr.io/outofmemoryerror/metaspace OverviewJava应用程序仅仅被允许使用有限的内存。当应用启动的时候，你的应用就确定了可以使用的内存量。为了让事情更复杂，Java内存分为下面的图中可以看到的不同的地区： 这些区域包括permgen区域，都在JVM启动时，被设置了。如果你没有设置这些，那么将会采取平台默认值。 当Metaspace的内存空间耗尽之后，将会触发The java.lang.OutOfMemoryError: Metaspace. What is causing it?如果你不是一个java新手，你可能更熟悉另一概念被称为永久代的Java内存管理。从Java8开始，java内存模型发生了显著变化，一个新的叫Metaspace的内存区域被引入了，同时Permgen被移除了。这个改变被归为以下几个原因，归为但不限定于： 永久带的区域需求无法预测，它总是会产生情况，要么内存不足，产生错误: java.lang.OutOfMemoryError: Permgen，要么供应过于充足，产生了很多浪费。 GC性能改进，启动并发类数据重新分配不会产生GC暂停和明显的迭代在Metadata中 支持如G1并行类卸载的进一步优化 所以如果你很熟悉永久代，这些你所有知道的可以作为背景–在Java8之前无论任何被分配在永久带的内容（类的名称，字段，作为字节码的方法，常量池，JIT优化等）–现在被分配在了Metaspace。 正如你看到的，Metaspace大小要求都依赖于加载的类的数量以及此类声明的大小。这是显而易见的，当在Metaspace空间加载太多的类或者太大的类，就会产生java.lang.OutOfMemoryError: Metaspace错误。 main cause for the java.lang.OutOfMemoryError: Metaspace is: either too many classes or too big classes being loaded to the Metaspace Give me an example正如前几个章节解释的，Metaspace的使用是和类的数量有很强的关联的在JVM中。以下展示一个最粗暴的例子： 123456789public class Metaspace &#123; static javassist.ClassPool cp = javassist.ClassPool.getDefault(); public static void main(String[] args) throws Exception&#123; for (int i = 0; ; i++) &#123; Class c = cp.makeClass(&quot;eu.plumbr.demo.Generated&quot; + i).toClass(); &#125; &#125;&#125; 这个源码就是循环生成类。所有这些生成的类定义最后都消耗着Metaspace空间。这些复杂的类都是javassist库生成的。 这个代码将会保持持续生成新的类，并在Metaspace中加载这些类定义，知道空间被占满，并且抛出错误java.lang.OutOfMemoryError: Metaspace.当在Mac OS X中采取Java 1.8.0_05版本启动时，带有参数-XX:MaxMetaspaceSize=64m大概会生成70000个类。 注：新参数（MaxMetaspaceSize）用于限制本地内存分配给类元数据的大小。如果没有指定这个参数，元空间会在运行时根据需要动态调整。 What is the solution?在面临OutOfMemoryError错误时，Metaspace是第一个解决方案应该是显而易见的。如果应用程序在内存耗尽元空间区域你应该增加元空间的大小。改变你的应用程序启动并增加以下配置： 1-XX:MaxMetaspaceSize=512m 上述Metaspace的配置示例指示JVM在抛出错误OutOfMemoryError时，将空间处理成512MB。 另一个解决方案是更简单。你可以删除Metaspace上所有的参数移除这个限制。注意这样操作之后，你将引入比较重的内存交换或者达到本地分配失败的情况。 在今晚结束之前，警告下–通常情况它会发生，通过使用上述建议“quick fixes”会隐藏这个错误java.lang.OutOfMemoryError: Metaspace，并不能解决根本问题。如果您的应用程序中内存泄漏的内存或只是一些不合理的加载到元空间上述解决方案实际上不会有什么助益，它只会推迟问题。]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-Kill process]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-Kill%20process%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError:Kill process or sacrifice child 前言本文翻译自 https://plumbr.io/outofmemoryerror/kill-process-or-sacrifice-child overview为了理解这种错误，我们需要恢复基本的操作系统。正如我们所知道的，操作系统都是由一系列的进程处理的。这些处理程序被几个主要的kernel jobs控制运行。其中一个进程叫做“Out of memory killer”进程，这是我们所感兴趣的。 当内存特别低的时候，kernel job就会杀掉你的进程。当这个条件出发时，Out of memory killer就会激活并杀掉一个进程。被选中的进程是来自于一个启发式的程序中，它会对所有的进程进行排分然后选择最差的得分去杀掉。Out of memory: Kill process or sacrifice child因此是不同于其他的java的OOM异常的。它不是由JVM触发的，也不是代理的，而是一个内置在操作系统内核中的安全网络。 Out of memory: kill process or sacrifice child error发生是由于所有可用虚拟内容（包括swap）被过度消耗，这会使得操作系统进入一定的风险状态。在这种情况下，Out of memory killer就会杀掉此进程。 What is causing it?默认情况下，Linux内核允许进程请求更多的内存，而不是系统中当前可用的内存。考虑到大多数进程从来没有真正使用它们分配的所有内存，这在全世界都有意义。与这种方法最简单的比较是宽带运营商。他们向所有消费者出售100MIT下载承诺，远远超过其网络中存在的实际带宽。该赌注再次基于用户不会同时使用他们分配的下载限制的事实。因此，一个10GBIT链路可以成功地服务于我们的简单数学允许的100个用户。 这种方法的副作用是可见的，在某些情况下，你的程序正在耗尽系统内存的路径。这可能导致非常低的内存条件，其中没有页面可以被分配来处理。你可能会遇到这样的情况，甚至根本没有一个根基帐户不能杀死违规的任务。为了防止这种情况，杀手激活，并识别流氓进程被杀死。 你可以阅读更多的内容关于“Out of memory killer” this article from RedHat documentation 现在我们有了这些上下文内容了，那么你怎么知道什么时候触发“killer”并在凌晨5点叫醒你？常见的一个激活操作触发器是隐藏在操作系统配置中。当您在/proc/sys／vm/overcommit_memory路径中，您将得到第一个提示——这里指定的值指示是否允许所有的malloc()调用成功。请注意，proc文件系统中的参数路径取决于受更改影响的系统。 过度提交配置即允许分配越来越多的内存用于这个无赖进程，这最终会触发“Out of memory killer”来完成它想要做的事情。 Give me an example编译并且运行以下的代码 123456789101112131415package eu.plumbr.demo;public class OOM &#123;public static void main(String[] args)&#123; java.util.List&lt;int[]&gt; l = new java.util.ArrayList(); for (int i = 10000; i &lt; 100000; i++) &#123; try &#123; l.add(new int[100_000_000]); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;&#125; 你将会在系统日志中见到如下的内容（/var/log/kern.log in our example） 12Jun 4 07:41:59 plumbr kernel: [70667120.897649] Out of memory: Kill process 29957 (java) score 366 or sacrifice childJun 4 07:41:59 plumbr kernel: [70667120.897701] Killed process 29957 (java) total-vm:2532680kB, anon-rss:1416508kB, file-rss:0kB 你需要去调整swapfile和heap尺寸。在我们的情况中，我们需要使用2g的内空间通过修改-Xmx2g并且配置如下的swap配置： 1234swapoff -a dd if=/dev/zero of=swapfile bs=1024 count=655360mkswap swapfileswapon swapfile What is the solution?有几种方法来处理这种情况。克服这个问题的第一个也是最直接的方法是将系统迁移到具有更多内存的实例。 其他的可能性包括对OOM杀手进行微调，在几个小实例中水平地缩放负载或减少应用程序的内存需求。 一个我们不愿意推荐的解决方案是涉及增加交换空间。当你回忆起Java是垃圾收集语言时，这个解决方案似乎已经不那么赚钱了。在物理内存中运行时，现代GC算法是有效的，但是当处理交换分配时，效率是被捶打的。交换可以在几个数量级内增加GC暂停的长度，所以在跳转到这个解决方案之前，你应该三思而后行。]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-heap space]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-heap%20space%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError:Java heap space 前言本文翻译自 https://plumbr.io/outofmemoryerror/java-heap-space OverviewJava程序仅仅被使用有限的内存空间。这个空间在程序被启动时指定了。为了让事情更复杂，java内存被分割成2个区域。这些区域被称为堆空间和永久代(用于永久代) 这些区域的大小被设置了在JVM启动时，并且能够通过JVM参数-Xmx和-XX:MaxPermSize定制。如果没有明确指定这些值，那么将使用平台特有的默认值。 java.lang.OutOfMemoryError: Java heap space error将会被触发，当应用程序试图添加更多的数据放进堆空间区域，但没有足够的空间给它。 when the application attempts to add more data into the heap space area, but there is not enough room for it 注意可能有很多可用的物理内存，但是每当JVM到达堆大小的限制时，都会抛出异常java.lang.OutOfMemoryError: Java heap space error What is causing it?抛出java.lang.OutOfMemoryError: Java heap space error大多数时候原因都是很简单的–你尝试去将XXL大小的应用程序装入S大小的堆空间。意思就是–应用程序需要更多堆空间去正常运作。还有其他导致OutOfMemoryError错误信息的原因更复杂并且由于程序错误： 使用/数据的容量峰值 应用程序被设计为处理一定量的用户或特定数量的数据，当用户或数据的数量突然暴涨并且穿过预期阈值。那么这些正常程序在峰值操作时就会导致触发java.lang.OutOfMemoryError: Java heap space error 内存泄漏 特定类型的编程错误会导致你的应用程序不断消耗更多的内存，每一次这个泄漏内存的功能被使用就会导致更多的内存对象进入到堆空间中。随着时间推移，泄漏的对象占用所有可用的Java堆空间并且会触发常见的错误java.lang.OutOfMemoryError: Java heap space错误。 Give me an example 普通的例子第一个例子是一个真实的例子–以下的java代码尝试去分配2M的Integer数组。当你完成它并且使用12M大小的java堆内存（java -Xmx12m OOM）启动时，它将会抛出错误java.lang.OutOfMemoryError: Java heap space，使用13M的java堆内存就会运行的很好。 123456class OOM &#123; static final int SIZE=2*1024*1024; public static void main(String[] a) &#123; int[] i = new int[SIZE]; &#125;&#125; 内存泄漏的例子第二个例子是一个更常见的内存泄漏的例子。在java中，当开发者创建和使用新对象时，例如new Integer(5)，他们并不需要关心是否分配了内存–JVM会处理它们。在应用程序的整个声明周期，JVM会定期检查哪些对象的内存正在被使用哪些不再使用了。不再使用的内存会被发现，并且内存会回收它再次利用，这个过程就叫做垃圾收集。在JVM收集中这个相对应的模版就叫做垃圾收集器（GC）. Java的自动内存管理依赖于GC定期查找未使用的对象并将它们删除，简单点说，内存泄漏在java中的场景就是当一些对象不再被应用使用了但是GC却无法识别回收他们。由于这些未使用的对象无限期的停留在堆空间，最后就导致了抛出异常：java.lang.OutOfMemoryError: Java heap space error. 以下就构建了一个内存泄漏的例子 1234567891011121314151617181920212223class KeylessEntry &#123; static class Key &#123; Integer id; Key(Integer id) &#123; this.id = id; &#125; @Override public int hashCode() &#123; return id.hashCode(); &#125; &#125; public static void main(String[] args) &#123; Map m = new HashMap(); while (true) for (int i = 0; i &lt; 10000; i++) if (!m.containsKey(new Key(i))) m.put(new Key(i), &quot;Number:&quot; + i); &#125;&#125; 当你运行上面的代码时候，你可能期望他永远没有任何问题。假如这个缓存解决方案仅仅将Map夸大到10000元素，那么所有的key都将被保存于hashMap中。然而现实中，这些key都将会加入到缓存中，这个类没有合适的equals()实现在hashCode()之后。 因此，随着时间的推移，这些含有内存泄漏的代码不断缓存结果最终就会消耗大量的java堆空间了。当这些泄漏的内存填充满了可用的堆空间并且GC无法清理它的时候，就会抛出异java.lang.OutOfMemoryError: Java heap space 解决方案很简单–实现equals()方法类似于下面这种，那么程序会很顺利的。但在找到这些原因之前，你需要浪费大量的脑细胞了。 12345678@Overridepublic boolean equals(Object o) &#123; boolean response = false; if (o instanceof Key) &#123; response = (((Key)o).id).equals(this.id); &#125; return response;&#125; What is the solution?有时候，你向JVM申请的内存数量是不够容纳你的应用所需要的。这种情况下，你应该分配更多的内存空间–看文章最后了解如何实现它。 然后在许多场景中，提供更多的内存空间将不会解决这个问题。例如，如果你的应用程序包含了内存泄漏，添加更多的内存空间仅仅会延长java.lang.OutOfMemoryError: Java heap space错误的抛出。增加Java堆空间的数量也会增加GC暂停影响您的应用程序的吞吐量或延迟的长度。 如果你想要根本的解决java堆问题而不是掩盖这个问题，你需要找出你的代码那一部分分配了最多的内存。换句话说，你需要回到如下问题： 哪个对象占据了最大的内存空间？ 这些对象在源代码中哪里被分配了？ 为了解决这些问题，你需要留个自己一些充足的时间（–看一看下面项目构建的列表）。这是一个解决问题的大纲，可以帮你解决这个问题。 获取到安全许可为了得到你的JVM中的堆空间dump文件。“Dumps”是堆空间的快照包含了你需要分析的内容。这些快照包含了机密信息，例如密码，卡号等等。因此你需要安全许可才能得到dump文件。 在适当的时候获取dump文件。在你获取一些dump文件时，如果是在错误的时间上，你将会获取一堆的噪音文件，几乎毫无用处。另一方面，每次获取dump文件时JVM可能完全的处于冻结状态，因此不要过多的获取这些dump文件不然你的用户将会面临性能问题。 找到可以加载dump文件的机器。当你的JVM需要排查8G以上的堆文件时，你需要超过8G以上内存的机器才能去分析堆内容。使用dump分析文件去分析（我们推荐Eclipse MAT，但也有其他更好的替代品） 检测堆中的最大消费者的GC根的路径。这里有篇文章来介绍如何处理.这是对初学者来说特别艰难，但实际上会让你了解结构和导航。 接下来，您需要找出源代码中的潜在危险大量对象被分配。如果你有好的应用程序源代码知识你可以做这几个搜索。 或者，我们推荐Plumbr, the only Java monitoring solution with automatic root cause detection。在其他的性能问题中，它也会一并捕获所有的java错误，并自动向你呈现这些信息，这些信息都是关于内存饥饿的数据结构。 Plumbr负责收集必要的数据在后台–这包括有关堆使用情况的相关数据（只有对象布局图，没有实际的数据）。同时也包含了一些你不能找到的java的堆数据。它也对这些数据做了必要处理–当JVM发生java.lang.OutOfMemoryError错误时。以下是一个Plumbr分析的附带的java.lang.OutOfMemoryError例子。 无需任何工具的情况下，你可以看到： 那个对象消费了大量的内存（271个com.example.map.impl.PartitionContainer实例消费了总248MB内存中的173MB） 这些对象被分配在了哪里（大多数的对象被分配在了MetricManagerImpl当中，line 304） 哪些是当前对象完整的引用（完整的引用链GC根） 配备此信息，您可以缩放到根本原因，并确保数据结构调整到正常水平，在这里他们会非常适合你的内存池。 但是，当你从内存分析或从阅读Plumbr报告得出的结论是，内存使用是合法的，源代码没有任何问题，那么您需要允许JVM更多Java堆空间才能正常运行。在这种情况下，改变您的JVM启动配置和添加(或增加价值如果存在)如下： 1-Xmx1024m 上面的配置将使Java堆空间的1024MB的应用。您可以使用g或G GB、m或M MB，k或K为KB。例如以下所有的都是等于说，最大的堆空间是1GB： 1234java -Xmx1073741824 com.mycompany.MyClassjava -Xmx1048576k com.mycompany.MyClassjava -Xmx1024m com.mycompany.MyClassjava -Xmx1g com.mycompany.MyClass]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOM-GC overhead]]></title>
    <url>%2F2019%2F07%2F15%2FOOM-GC%20overhead%2F</url>
    <content type="text"><![CDATA[标题java.lang.OutOfMemoryError:GC overhead limit exceeded 前言本文翻译自 https://plumbr.io/outofmemoryerror/gc-overhead-limit-exceeded overviewjava运行环境包含了一个内件的Garbage Collection(GC)进程。在许多其他的语言中，开发者需要自己手动分配和释放内存区域这样他们才能够再次利用被释放的内存。 java应用程序从另一方面将仅仅需要分配内存，每当一片内存区域不再使用时，一个叫垃圾收集器的进程就会开始清理这些内存。GC如何发现这块内存区域在Garbage Collection Handbook已经解释了，但是你可以相信GC工作做的非常好。 当你的应用程序已经用尽了所有可用的内存，而GC多次都没办法清除它时将会报错java.lang.OutOfMemoryError: GC overhead limit exceeded error What is causing it?java.lang.OutOfMemoryError: GC overhead limit exceeded这个错误表明了你的应用程序花费了太多的时间在做垃圾回收了但是得到的结果很少。默认情况下，如果JVM花费了总时间的98%以上在做GC，而在GC之后只有少于2%的堆被恢复，JVM就会被配置抛出这个错误来。 By default the JVM is configured to throw this error if it spends more than 98% of the total time doing GC and when after the GC only less than 2% of the heap is recovered. 当GC overhead limit不存在将会发生什么呢？请注意当几个GC周期之后每次只能释放不到2%的内存是java.lang.OutOfMemoryError: GC overhead limit exceeded错误将会被抛出，这意味着只有少量的堆能够被GC清理完成并且这些堆会再次立刻被填充上，再次强迫GC去重启清理进程。这就形成了一个恶性循环，CPU会100%运行用于GC并且实际的工作没法做。应用程序端的用户将会面对极端的慢-往常在几毫秒完成的操作将会花费i数分钟才能完成。 因此java.lang.OutOfMemoryError: GC overhead limit exceeded消息是一个执行快速失败原则中很好的例子了。 Give me an example在以下的例子中，我们能够创建一个GC overhead limit exceeded异常通过初始化一个map并且添加key-value对到这个map中在一个无限循环中： 123456789class Wrapper &#123; public static void main(String args[]) throws Exception &#123; Map map = System.getProperties(); Random r = new Random(); while (true) &#123; map.put(r.nextInt(), &quot;value&quot;); &#125; &#125;&#125; 正如你可能猜测这不能有好结果。 而事实上，当我们发布以下方案： 1java -Xmx100m -XX:+UseParallelGC Wrapper 这个应用程序将会挂掉，当Map调整长度（resize）时，将会抛出一个更通用的异常java.lang.OutOfMemoryError: Java heap space信息。当我运行其他垃圾收集算法时，除了ParallelGC之外，例如-XX:+UseConcMarkSweepGC或者-XX:+UseG1GC时，这个错误将会有默认的异常处理程序捕获，并且堆被耗尽时的程度并没有堆栈跟踪，这个堆栈跟踪不能填充这个异常区域。 这些变化是一个非常好的例子，说明了在资源受限的情况下，你不能预测你的程序将要死亡，因此，不要将你的期望基于这些特定的要完成的操作上。 What is the solution?作为一个半开玩笑的建议，如果你仅仅想清除java.lang.OutOfMemoryError: GC overhead limit exceeded信息，你可以添加如下的代码他将会实现这个： 1-XX:-UseGCOverheadLimit //关闭特性 我强烈建议不要使用这种选项–代替去修复这个你只是延迟的不可避免的问题：这个应用程序内存运行不足并且需要被修复。加上这些选项将会掩盖原始的错误java.lang.OutOfMemoryError: GC overhead limit exceeded并抛出一个通用的异常java.lang.OutOfMemoryError: Java heap space 换一个严肃的话题–有时候GC开销错误被触发是因为你给你的JVM分配的堆内存数量不能够适应你程序的需要在这个JVM上，这种情况，你应该加大你的内存容量–看文章的最后，如何去实现它。 然而在许多情况下，提供更多的内存空间并不能解决这个问题。例如，假如你的应用程序有内存泄漏，添加更多的内存将会延期java.lang.OutOfMemoryError: Java heap space error错误信息，同时，添加堆内存也会倾向于增加GC暂停影响您的应用程序的吞吐量或延迟的长度。 如果你想解决根本问题与Java堆空间而不是掩蔽症状，您需要弄清您的代码的哪一部分是负责分配最多内存。换句话说，你需要回答这些问题： 哪个对象占用了大量的堆空间 这些对象在代码中哪里被分配了 在这一点上，可能需要消耗你2天时间(或者请参阅下面的自动项目符号列表)。这是一个艰难的过程大纲，它将帮助你回答上述问题： 得到从你的JVM-toTroubleshoot（JVM排查）的堆栈dump文件。”Dumps”基本上是堆内容的快照，它可以分析，并包含所有应用程序时保存在内存转储。包括密码、信用卡号码等。 将JVM堆内存的信息转储到一个文件中。如果我们在错误的时间采集一些dump文件，这些文件将会含有大量的噪声，几乎毫无用处。在另一方面，每次堆栈丢弃这些JVM完全冻结的线程，不要这种文件太多，免得同事咒骂。(On the other hand, every heap dump “freezes” the JVM entirely, so don’t take too many of them or your end users start swearing.) 找到一台可以加载dump的机器。在JVM排查错误中假如你使用了8GB的堆，那你需要在8GB以上的计算机能够分析堆内容。用分析软件打开它(推荐使用Eclipse MAT，也有其他好用的替代品) 检测堆中最大消费者的GC根路径。这篇文章覆盖了如何去处理。别担心，起初你会觉得它很难，之后几天你会得到更好的挖掘。 接下来，您需要找出源代码中的潜在危险大量对象被分配。如果你熟悉您的应用程序的源代码，那么您会很快找到这些地方。当你运气不佳时，你可能需要更多的能量饮料协助。 另外，我们建议采取Plumbr（Java监视解决方案与自动检测根本原因）在其他性能问题中，它会捕获所有的java.lang.OutOfMemoryErrors错误，并且自动给你内存渴望的数据结构信息。它会收集必要的数据在后台–这包括有关堆使用情况数据(仅对象布局图，没有实际的数据)，还有一些你甚至不能发现的堆文件。它还为你做了必要的数据处理–当JVM遭遇了java.lang.OutOfMemoryError，以下是个OutofMemoryError的例子，通过plumbr: 无需任何的分析工具，你可以看到： 哪个对象消费着最大的内存(271个PartitionContainer实例消费了总共248MB内存中的173MB) 这些对象在哪里被分配了（大多数的对象被分配在MetricManagerImpl中） 当前哪些引用着这些对象（完整引用链到GC根） 具有这些，您可以缩放到的根本原因，并确保数据结构是下调至水平，在这里他们会非常适合你的内存池。 但是，当你从内存分析或从阅读Plumbr报告得出的结论是，内存使用是合法的，没有异议在源代码中，您需要允许JVM更多Java堆空间才能正常运行。在这种情况下，改变您的JVM启动配置和添加(或增加价值如果存在)就启动脚本中的一个参数： 1java -Xmx1024m com.yourcompany.YourClass 在上面的示例中给出了Java进程堆的1GB。作为最适合的值修改为您的JVM。 但是，如果结果与内存溢出错误，JVM仍然死了，你可能仍然无法避免上述手动或Plumbr辅助分析。]]></content>
      <categories>
        <category>OOM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo计划]]></title>
    <url>%2F2019%2F07%2F15%2FHexo%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[目前原来的文章都是直接放到git管理，采取markdown格式，没有样式存在，查看很不方便。遂决定采取hexo方式进行展示。目前来看hexo还是很好的展现方式，对于个人搭建博客，新域名方面，觉得太麻烦了，付费也是极大的问题，而CSDN等网站，商业性太夸张了，不好查看，还是放在github采取hexo方式最好了。以后有时间了，会再搭建一份采取VuePress方式进行。 主要内容平时自己积累的东西会放到record文档当中去，进行不断完善，总结。当record中的文章已经成熟了，没有问题了，会进行移动操作，将文章移动到此hexo当中去，当做稳定的归档版本来处理。后续不出问题的话，流程暂待如此处理。 后续计划闲了没事的话，会不断完善hexo相关的设置吧，对于文章方面，归类处理这些也会进行总结，尝试的。有了新的内容都会不断更新上去。SEO的优化也会后续闲了慢慢添加处理。github上写博客虽然不是很正规，但也是符合技术上面的，也可以的。github pages其他项目也是可以写的，后续会再开一个其他项目，写其他的内容。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-world]]></title>
    <url>%2F2019%2F07%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
